(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{433:function(a,t,e){"use strict";e.r(t);var s=e(51),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"seastar架构介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#seastar架构介绍"}},[a._v("#")]),a._v(" Seastar架构介绍")]),a._v(" "),e("h2",{attrs:{id:"seastar异步编程基石"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#seastar异步编程基石"}},[a._v("#")]),a._v(" Seastar异步编程基石")]),a._v(" "),e("ul",[e("li",[a._v("Future")])]),a._v(" "),e("p",[a._v("Future代表一个值可能未定的计算结果，这个结果可能现在不能马上得到，需要等待到将来某个时间点。这种future可以是网络传输的一个缓存，定时器的到期，磁盘写的完成等，它可以是任意一个需要等待的结果。")]),a._v(" "),e("p",[a._v("一般我们把一个异步函数的返回值作为一个future，这个future最终向调用者提供结果。例如我们可以用future<int> read来表示读取磁盘文件的结果，这个结果是一个int值，这个read函数没有任何等待，")]),a._v(" "),e("p",[a._v("立马返回给我们一个future<int>. 调用者调用future.available()检查值是否可用，一旦可用，就用future.get获取相应的值。")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("Promise")])]),a._v(" "),e("li",[e("p",[a._v("高阶接口")])])]),a._v(" "),e("p",[a._v("Seastar在f-p-c基础上还实现了更高级的接口：")]),a._v(" "),e("ol",[e("li",[a._v("异步操作的并行执行parallel_for_each")]),a._v(" "),e("li",[a._v("异步操作的循环执行repeat")]),a._v(" "),e("li",[a._v("同步等待异步操作的执行when_all")]),a._v(" "),e("li",[a._v("对于map reduce支持")]),a._v(" "),e("li",[a._v("Semaphore，gate和pipe等接口。")])]),a._v(" "),e("p",[a._v("从这里可以看出，Seastar是一个完备的支持异步编程的框架。")]),a._v(" "),e("h2",{attrs:{id:"seastar架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#seastar架构"}},[a._v("#")]),a._v(" Seastar架构")]),a._v(" "),e("p",[a._v("Seastar是一个基于分片的异步编程框架： 它能够实现复杂的服务器逻辑，保证网络和存储操作，多核之间操作的异步性，以达到高性能和低延迟的目标。图四可以清楚地看出Seastar相对于传统数据栈的优势。")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/scylla/seastar-4.png",alt:""}})]),a._v(" "),e("ol",[e("li",[e("p",[a._v("内存shard")]),a._v(" "),e("p",[a._v("Seastar运行后会保留（--reserve-memory）一小部分内存给操作系统或者预留（-m）一定数量的内存给自己。这样，Seastar对分配给自己的物理内存也进行了分片（shard），每个core有自己的内存空间，有自己的memory allocator（log-structured）对内存区域进行分配和释放管理，无需考虑thread safe和内存碎片化（定期compact，移动object，合并memory holes）。图五对比了基于JVM和Seastar的内存管理：")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/scylla/seastar-5.png",alt:""}})])]),a._v(" "),e("li",[e("p",[a._v("网络shard")]),a._v(" "),e("p",[a._v("所有的网络连接在cores之间分片（shard），每个core只负责处理自己那部分数据连接。\n但是对于Posix network stack，尽管在Seastar这一层是shar-nothing设计，由于Seastar需要和下方OS network stack进行交互，这样就可能有锁，原子操作，CPU 缓存的miss，性能不可避免地受到损失。所以要想获得最佳性能，推荐配置Seastar native network stack。")])]),a._v(" "),e("li",[e("p",[a._v("用户态task调度")]),a._v(" "),e("p",[a._v("Seastar任务调度和传统线程调度：")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/scylla/seastar-6.png",alt:""}})]),a._v(" "),e("p",[a._v("每个core上都有一个task scheduler，相对于内核中的thread，每个task都是一个轻量级的任务。Seastar中有两种类型task：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("a)\tNon-threaded context task 这种task一般很短，没有自己的栈，主要由Lambda函数组成，event-loop 主线程循环调度task队列中的Lambda函数。当然如果这种task不能立即执行，是需要内存空间来保存相应的状态，不过比起thread栈来说，开销很小。")])]),a._v(" "),e("li",[e("p",[a._v("b)\tThreaded context task 这种task的实现实际上就是用户态协程：它们有自己的栈，只会主动让出(yield) CPU，用setjmp/longjmp进行用户态的上下文切换，有相应的调度policy（例如基于时间片的调度去保证公平性）。\n所有这些用户态task不能调用blocking系统调用，因为整个core只有一个系统thread。有时候又不得不调用blocking系统调用，那只能另起一个Posix thread。所以大部分时间，整个core只有一个Posix thread在运行，有时候会是两个。")])])])]),a._v(" "),e("li",[e("p",[a._v("用户态 disk I/O的调度")]),a._v(" "),e("p",[a._v("Seastar利用操作系统libaio提供的io_submit去提交磁盘操作和io_getevent来收集操作结果，从而实现磁盘I/O操作的异步性。但Linux对于aio支持的并不是很好，并不是所有文件系统都支持aio,即使有的支持,也有很多问题。最新的xfs对于aio支持的很好，所以对于disk IO，只推荐采用xfs。由于在内核中，从文件系统（file system）到块设备层（block level）再到具体的存储设备层，每个层都有I/O队列，对I/O进行了自己的管理。一旦storage I/O出现拥塞，不太容易判断哪层出现问题，也不好采取措施进行调控。因此，Seastar在用户态实现了I/O scheduler，对磁盘I/O进行精确的分级控制和调优。Seastar有自己的I/O queue来缓存I/O，并实现了各种 I/O priority class，从而保证各种I/O调度的公平性。Seastar实现的用户态I/O调度器：")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/scylla/seastar-6.png",alt:""}})])]),a._v(" "),e("li",[e("p",[a._v("用户态原生网络栈(Native network stack)")]),a._v(" "),e("p",[a._v("图八描绘了Seastar的网络栈，即包含Posix stack，也包含原生网络栈")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/scylla/seastar-6.png",alt:""}})]),a._v(" "),e("p",[a._v("除了支持常规的Posix network stack， Seastar还支持基于DPDK的native network stack。大家知道，DPDK是Intel推出的一个高性能用户态网络管理包，其核心思想和Seastar是一致的：用户态轮询(poll)模式的网卡驱动，没有中断，没有上下文切换，没有内存拷贝，无锁，share-nothing，自己的内存管理，利用NUMA等等。DPDK主要提供L2数据包处理功能，需要上层应用提供L3及以上的网络管理。Seastar实现了TCP/IP协议：每个core绑定到物理网卡的一个接受队列和发送队列，这样所有的数据连接也被分片（shard），每个core自始至终只负责自己那部分数据连接。对于native network stack，没有syscall调用，没有多余的数据复制，没有锁，性能当然最好。")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);