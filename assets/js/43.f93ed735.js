(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{434:function(a,e,t){"use strict";t.r(e);var r=t(51),s=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"seastar架构介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#seastar架构介绍"}},[a._v("#")]),a._v(" Seastar架构介绍")]),a._v(" "),t("h2",{attrs:{id:"seastar简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#seastar简介"}},[a._v("#")]),a._v(" Seastar简介")]),a._v(" "),t("p",[a._v("概括来说，Seastar 是一个开源，基于c++ 11/14 feature，支持高并发和低延迟的异步编程高性能库。要想深入学习Seastar，需要掌握新的C++ features，这些features包括：")]),a._v(" "),t("ol",[t("li",[a._v("Auto/decltype")]),a._v(" "),t("li",[a._v("Tuple")]),a._v(" "),t("li",[a._v("Variadic Template可变参数的模板")]),a._v(" "),t("li",[a._v("Move copy/Assignment 移动拷贝/移动赋值")]),a._v(" "),t("li",[a._v("Metaprogramming 模板元编程")]),a._v(" "),t("li",[a._v("Lambda函数")]),a._v(" "),t("li",[a._v("Smart pointers智能指针")]),a._v(" "),t("li",[a._v("Future/promise")])]),a._v(" "),t("p",[a._v("这些新的特性很复杂，背后都有深厚的学术和业界工程实践的积累，学习起来有一定难度。实际上Seastar代码里充斥着几乎所有新的C++ features和新的c++库中的APIs （包括STD 和boost库）。\n而且为了自己的需要，Seastar扩展了C++标准中的部分特性。例如STD中的future/promise就不能满足Seastar复杂的异步编程的需要，为此，Seastar实现了广泛的future/promise接口。\n同时，Seastar重新实现了一些有别于标准库中的数据结构，因为像thread safe这样的要求是无需考虑的。所以，阅读Seastar这样的匠心之作肯定能带来别样的收获。")]),a._v(" "),t("h2",{attrs:{id:"seastar的来源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#seastar的来源"}},[a._v("#")]),a._v(" Seastar的来源")]),a._v(" "),t("p",[a._v("说到Seastar，不得不说Scylla。Scylla是2015年9月开源，由大神KVM之父Avi Kivity创建的NoSQL数据库，接口协议完全兼容Cassandra，但性能号称快了10倍：每节点1 million IOPS。\nScylla完全基于Seastar库，由C++改写的Cassandra。所以Scylla的惊鸿面世也带来了大家对于Seastar的瞩目。实际上，Scylla只是Seastar的一个应用，\n其他应用如Pedis也佐证了Seastar是整个应用性能提升的基石。下图一和图二为Scylla官方给出的测试数据：")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/scylla/seastar-1.png",alt:""}}),a._v(" "),t("img",{attrs:{src:"/img/scylla/seastar-2.png",alt:""}})]),a._v(" "),t("p",[a._v("那疑问来了，凭什么只用C++改写，就能带来如此巨大的性能差异，莫非C++带来了神秘的魔法功效。可JAVA之类的语言不服，凭什么啊（ ）。这里抛开语言之间的差异不谈，\nSeastar采用了一套新的编程模式，从而最大化去利用硬件的性能。\n如图三所示，从总体架构而言，Seastar是一个完全分片（share-nothing）的设计：每个logic core 一个thread，每个core有自己的资源：CPU, network, disk I/O, memory。\n多个core之间没有资源的竞争，随着core数量的增加，扩展性和性能也随之提升。对于多个core之间的通信，采用point-to-point queue发送和接受异步消息。\n所有core之间没有数据共享，没有锁，没有cache lines频繁的miss。与此同时，Seastar也是一个异步编程框架，下文会进一步深入展开。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/img/scylla/seastar-3.png",alt:""}})]),a._v(" "),t("h2",{attrs:{id:"异步编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程"}},[a._v("#")]),a._v(" 异步编程")]),a._v(" "),t("h3",{attrs:{id:"为什么需要异步编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要异步编程"}},[a._v("#")]),a._v(" 为什么需要异步编程")]),a._v(" "),t("p",[a._v("随着硬件的高速发展（SSD, 10G/40G network, NUMA），软件开发人员的技能还停留在传统的开发模式上，这样写出来的程序就限制了新硬件性能的发挥：")]),a._v(" "),t("ul",[t("li",[a._v("当硬件发展到了一定阶段，单核的性能很难再飞速增长")]),a._v(" "),t("li",[a._v("多核的数量在增加，但应用很难有效利用他们")]),a._v(" "),t("li",[a._v("锁的开销很大\n在传统的多进程/线程的编程中，锁是保证数据安全的重要手段。由于资源(file, memory)的竞争, 进程/线程不得不阻塞等待。据实验测试，一个高并发的应用，20%~70%的时间可能耗在无谓的锁等待上。")]),a._v(" "),t("li",[a._v("数据分配在一个核上，可能复制和使用在别的核上\n例如一个网卡的中断程序运行在一个core上，而后续的数据包的处理可能迁移到别的core上，这样CPU的cache line频繁的miss，造成性能的penalty。")]),a._v(" "),t("li",[a._v("用户态/内核态，进程线程/中断上下文切换的开销")])]),a._v(" "),t("h3",{attrs:{id:"异步编程的起源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程的起源"}},[a._v("#")]),a._v(" 异步编程的起源")]),a._v(" "),t("p",[a._v("同步和异步区别是什么？同步意味着一个操作必须等待它调用的其他操作完成后才能继续进行下一步的操作。而异步则是无需等待，当一个操作调用一个会阻塞的操作时，\n它会接着做别的事情，等那个阻塞的操作完成时，会发一个event通知它，那么它接着处理这个阻塞的操作。")]),a._v(" "),t("p",[a._v("我们看看传统的一个network server 是如何处理并发的网络连接：当一个client连接到来时，一个新的process或者thread被fork 出来，\n即使某个连接调用一个阻塞(blocking)的系统调用(syscall)也没有关系，因为可以有的其他process或者thread来处理新的连接。\n为什么说这种编程是同步的呢？因为代码的执行就如程序员所写一样是线性的，严格按照一行一行代码的逻辑顺序执行。尽管从操作系统角度来说，\n本质上系统是并发执行的：当一个process/thread 调用一个阻塞的系统调用时，OS会自动切换到另一个合适的process/thread去执行。\n同步编程是有开销的：首先，fork一个新的process或者thread很慢，再加上如果大量的操作被阻塞，随之发生的频繁进程/线程上下文切换的代价也很大。\n除此之外，每个process/thread需要有自己独立的栈空间，如果系统中process/thread很多，栈的内存开销也会很大。")]),a._v(" "),t("p",[a._v("最近一些年，异步编程开始流行起来。各种语言从Python， JaveScript，Go到C++纷纷开始支持异步编程。一个server是异步的，\n那么它本质上是事件驱动的（event-driven）。通常只有一个thread，这个thread就是一个迭代循环执行。每次迭代它都要轮询（poll）有没有新的事件（event）要处理，\n如果有，可以调用相应的已经注册好的具体事件处理函数。事件的处理是run-to-completion，也即意味着main thread不会处理下一个even，\n除非上一个event已经处理完成。这些event可以对应网络socket连接，存储disk I/O和计时器等。这样整个系统没有thread休眠和锁造成的休眠或者忙等待，\n所有的组成构件都在不停地运转，系统性能达到最优。当然，对于Seastar来说，是每个core一个这样thread，它称之为engine。")]),a._v(" "),t("h3",{attrs:{id:"异步编程的挑战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程的挑战"}},[a._v("#")]),a._v(" 异步编程的挑战")]),a._v(" "),t("ul",[t("li",[a._v("复杂性")])]),a._v(" "),t("p",[a._v("代码不再像之前同步编程时可读性那么好。许许多多从简单到复杂的回调函数嵌入（递归嵌入）到各种代码分支中，大部分时候，程序员阅读所见的代码并不一定能在逻辑上顺序执行到，\n执行的时机取决于一些状态值。要妥善安排这些代码之间的关系（event 和 event hander）并非易事。为了减少这种异步带来的复杂性，Seastar实现了future/promise对象，\n用来管理这些异步操作。这样基于回调函数的编程就变成了基于future/promise的编程。")]),a._v(" "),t("ul",[t("li",[a._v("非阻塞模式")])]),a._v(" "),t("p",[a._v("因为每个core上只有一个thread在运行，这个thread不能被阻塞。所以它不能直接或者间接调用任何可能阻塞的系统调用，也不能调用锁接口以防止死锁。")])])}),[],!1,null,null,null);e.default=s.exports}}]);