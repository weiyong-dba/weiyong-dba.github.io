(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{415:function(e,a,v){"use strict";v.r(a);var s=v(51),t=Object(s.a)({},(function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"redis4新特性介绍及cluster架构基本原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis4新特性介绍及cluster架构基本原理"}},[e._v("#")]),e._v(" Redis4新特性介绍及Cluster架构基本原理")]),e._v(" "),v("h2",{attrs:{id:"新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#新特性"}},[e._v("#")]),e._v(" 新特性")]),e._v(" "),v("h3",{attrs:{id:"模块系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块系统"}},[e._v("#")]),e._v(" 模块系统")]),e._v(" "),v("p",[e._v("Redis 4.0发生的最大变化就是加入了模块系统，这个系统可以让用户通过自己编写的代码来扩展和实现Redis本身并不具备的功能。\n模块系统通过高层次API实现的，它与Redis内核本身完全分离、互不干扰，用户可以在有需要的情况下才启用这个功能。")]),e._v(" "),v("h3",{attrs:{id:"主从数据同步机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从数据同步机制"}},[e._v("#")]),e._v(" 主从数据同步机制")]),e._v(" "),v("ul",[v("li",[e._v("PSYNC2: 新的一种主从复制同步机制。")]),e._v(" "),v("li",[e._v("PSYNC1: 2.8~4.0之前版本的同步为PSYNC1。")])]),e._v(" "),v("h3",{attrs:{id:"慢日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#慢日志"}},[e._v("#")]),e._v(" 慢日志")]),e._v(" "),v("p",[e._v("记录客户端来源IP地址，这个小功能对于故障排查很有用处。")]),e._v(" "),v("h3",{attrs:{id:"nat／docker支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nat／docker支持"}},[e._v("#")]),e._v(" NAT／DOCKER支持")]),e._v(" "),v("h3",{attrs:{id:"非阻塞-del-、-flushdb-和-flushall"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞-del-、-flushdb-和-flushall"}},[e._v("#")]),e._v(" 非阻塞 DEL 、 FLUSHDB 和 FLUSHALL")]),e._v(" "),v("p",[e._v("delete\\rename\\淘汰过期大key时放后台运行")]),e._v(" "),v("h3",{attrs:{id:"交换数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#交换数据库"}},[e._v("#")]),e._v(" 交换数据库")]),e._v(" "),v("p",[e._v("可以对指定的两个数据库进行互换： 比如说，通过执行命令SWAPDB 0 1，我们可以将原来的数据库0变成数据库1，而原来的数据库1则变成数据库0。CLUSTER中不支持。")]),e._v(" "),v("h3",{attrs:{id:"混合rdb-aof持久化格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#混合rdb-aof持久化格式"}},[e._v("#")]),e._v(" 混合RDB-AOF持久化格式")]),e._v(" "),v("p",[e._v("可选， AOF重写产生的文件将同时包含RDB格式的内容和AOF格式的内容，其中RDB格式的内容用于记录已有的数据， 而AOF格式的内存则用于记录最近发生了变化的数据，这样 Redis就可以同时兼有RDB持久化和AOF持久化的优点——既能够快速地生成重写文件，也能够在出现问题时，快速地载入数据。")]),e._v(" "),v("p",[e._v("开启方法：")]),e._v(" "),v("blockquote",[v("p",[e._v("aof-use-rdb-preamble yes")])]),e._v(" "),v("p",[e._v("不需要bgsave，在内存紧张时有用。")]),e._v(" "),v("h3",{attrs:{id:"least-frequently-used"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#least-frequently-used"}},[e._v("#")]),e._v(" Least Frequently Used")]),e._v(" "),v("p",[e._v("新增了allkey-lfu和volatile-lfu两种数据逐出策略，可以通过object命令来获取某个 key 的访问频度。")]),e._v(" "),v("div",{staticClass:"language-shell line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[e._v("object freq user_key\nredis-cli –hotkeys\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br")])]),v("p",[e._v("已有策略：")]),e._v(" "),v("ul",[v("li",[e._v("volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰")]),e._v(" "),v("li",[e._v("volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰")]),e._v(" "),v("li",[e._v("volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰")]),e._v(" "),v("li",[e._v("allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰")]),e._v(" "),v("li",[e._v("allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰")]),e._v(" "),v("li",[e._v("no-enviction（驱逐）：禁止驱逐数据")])]),e._v(" "),v("p",[v("strong",[e._v("注：")])]),e._v(" "),v("ul",[v("li",[e._v("LRU数据淘汰机制：在数据集中随机选取几个键值对，选择lru最大的一部分键值对。")]),e._v(" "),v("li",[e._v("LFU数据淘汰机制：在数据集中随机选取几个键值对，选择lfu最小的一部分键值对。")]),e._v(" "),v("li",[e._v("TTL数据淘汰机制：从设置过期时间的数据集中随机选取几个键值对，选择TTL最大的一部分键值对。")])]),e._v(" "),v("h3",{attrs:{id:"新增memory命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#新增memory命令"}},[e._v("#")]),e._v(" 新增MEMORY命令")]),e._v(" "),v("p",[e._v("新添加了一个MEMORY命令， 这个命令可以用于视察内存使用情况，并进行相应的内存管理操作。")]),e._v(" "),v("ul",[v("li",[e._v("MEMORY USAGE 子命令可以估算储存给定键所需的内存。")]),e._v(" "),v("li",[e._v("MEMORY STATS 子命令可以查看 Redis 当前的内存使用情况。\n"),v("img",{attrs:{src:"/img/redis/redis-memory-stat.png",alt:""}})]),e._v(" "),v("li",[e._v("MEMORY PURGE 子命令可以释放更多内存。")]),e._v(" "),v("li",[e._v("MEMORY MALLOC-STATS 子命令可以展示分配器内部状态。")]),e._v(" "),v("li",[e._v("MEMORY DOCTOR\n"),v("ul",[v("li",[e._v("Peak memory: peak.allocated/total.allocated > 1.5，此时内存碎片率可能比较高")]),e._v(" "),v("li",[e._v("High fragmentation: fragmentation > 1.4，此时碎片率比较高")]),e._v(" "),v("li",[e._v("Big slave buffers: 每个slave缓冲区的平均内存超过10MB，原因可能是master写入流量过高")]),e._v(" "),v("li",[e._v("Big client buffers: 普通客户端缓冲区的平均内存超过200KB，原因可能是pipeline使用不当或者Pub/Sub客户端处理消息不及时导致")])])])]),e._v(" "),v("h2",{attrs:{id:"redis-cluster"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster"}},[e._v("#")]),e._v(" Redis Cluster")]),e._v(" "),v("h3",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),v("p",[e._v("2015年4月1日发布redis 3.0.0 stable版，Redis 集群是一个分布式Redis 实现，具有一定容错性和线性扩展性，功能是普通单机 Redis 所能使用的功能的一个子集。")]),e._v(" "),v("p",[v("strong",[e._v("主要功能有：")])]),e._v(" "),v("ul",[v("li",[e._v("可线性扩展到上千个节点，理论上是16384")]),e._v(" "),v("li",[e._v("可使数据自动路由到多个节点")]),e._v(" "),v("li",[e._v("可支持动态增加或删除节点")]),e._v(" "),v("li",[e._v("可保证某些节点无法提供服务时不影响整个集群的操作")]),e._v(" "),v("li",[e._v("不保证数据的强一致性")])]),e._v(" "),v("p",[v("strong",[e._v("命令特性：")])]),e._v(" "),v("ul",[v("li",[e._v("支持Redis所有处理单个数据库键的命令")]),e._v(" "),v("li",[e._v("不支持对多个数据库键的操作，比如MSET、SUNION（有例外处理）")]),e._v(" "),v("li",[e._v("不能使用SELECT 命令，集群只使用默认的0号数据库")])]),e._v(" "),v("h3",{attrs:{id:"原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),v("p",[e._v("集群空间分成16384个槽，最大节点数也是16384，推荐节点数1000左右。根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。")]),e._v(" "),v("p",[e._v("每个Redis物理结点负责一部分桶的管理，当发生Redis节点的增减时，调整桶的分布即可。\v例如，假设Redis Cluster三个节点A/B/C，则\v\n"),v("img",{attrs:{src:"/img/redis/redis-cluster-theory.png",alt:""}})]),e._v(" "),v("ul",[v("li",[e._v("Node A 包含桶的编号可以为: 0 到 5000")]),e._v(" "),v("li",[e._v("Node B 包含桶的编号可以为: 5001 到 10000")]),e._v(" "),v("li",[e._v("Node C包含桶的编号可以为: 10001 到 16383")])]),e._v(" "),v("p",[e._v("当发生Redis节点的增减时，调整桶的分布即可。")]),e._v(" "),v("h3",{attrs:{id:"架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[e._v("#")]),e._v(" 架构")]),e._v(" "),v("p",[v("img",{attrs:{src:"/img/redis/redis-cluster-theory-2.png",alt:""}})]),e._v(" "),v("p",[e._v("所有节点彼此互联，内部使用Gossip 协议协议优化传输速度和带宽。")]),e._v(" "),v("p",[e._v("客户端与节点直连,不需要中间proxy层，客户端不需要连接集群所有节点,\v连接集群中任何一个可用节点(包括slave节点)即可。")]),e._v(" "),v("p",[e._v("所有的物理节点映射到[0-16383]slot上,cluster 负责维护node<->slot<->value")]),e._v(" "),v("h3",{attrs:{id:"ha"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ha"}},[e._v("#")]),e._v(" HA")]),e._v(" "),v("p",[v("strong",[e._v("Master-Slave")])]),e._v(" "),v("p",[v("img",{attrs:{src:"/img/redis/redis-cluster-ha.png",alt:""}})]),e._v(" "),v("p",[e._v("每个Redis Node可以有一个或者多个Slave，当Master挂掉时，选举一个Slave形成新的Master，老Master恢复后会自动成为Slave。一个Redis  Node包含一定量的桶，当这些桶对应的Master和Slave都挂掉时，这部分桶对应的数据不可用，集群也不可用。")]),e._v(" "),v("p",[e._v("新的主节点选举的条件：")]),e._v(" "),v("ul",[v("li",[e._v("这个节点是已下线主节点的从节点")]),e._v(" "),v("li",[e._v("已下线主节点负责处理的槽数量非空")]),e._v(" "),v("li",[e._v("从节点的数据被认为是可靠的， 也即是， 主从节点之间的复制连接的断线时长不能超过节点超时时限（node timeout）乘以 REDIS_CLUSTER_SLAVE_VALIDITY_MULT 常量得出的积")])]),e._v(" "),v("h3",{attrs:{id:"数据迁移"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据迁移"}},[e._v("#")]),e._v(" 数据迁移")]),e._v(" "),v("h4",{attrs:{id:"原理-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原理-2"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),v("p",[e._v("MIGRATE命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等到超时。")]),e._v(" "),v("h4",{attrs:{id:"步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[e._v("#")]),e._v(" 步骤")]),e._v(" "),v("ol",[v("li",[e._v("在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例。")]),e._v(" "),v("li",[e._v("目标实例使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中。")]),e._v(" "),v("li",[e._v("如果RESTORE返回OK，当前实例调用 DEL 删除自己数据库上的 key。")])]),e._v(" "),v("h4",{attrs:{id:"异常处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异常处理"}},[e._v("#")]),e._v(" 异常处理")]),e._v(" "),v("p",[e._v("IO错误、超时等")]),e._v(" "),v("ul",[v("li",[e._v("key 可能存在于两个实例")]),e._v(" "),v("li",[e._v("key 可能只存在于当前实例")]),e._v(" "),v("li",[e._v("不会丢失 key")])]),e._v(" "),v("h3",{attrs:{id:"集群在线重配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集群在线重配置"}},[e._v("#")]),e._v(" 集群在线重配置")]),e._v(" "),v("p",[e._v("支持在线增/减节点，将数据桶从一个Redis Node迁移到另一个Redis Node即可完成迁移，当桶从一个Node A向另一个Node B迁移时，Node A和Node B都会有这个桶，Node A上桶的状态设置为MIGRATING，Node B上桶的状态被设置为IMPORTING。桶里面的所有键通过MIGRATE指令原子地从节点A移动到节点B。")]),e._v(" "),v("p",[e._v("当客户端请求正在迁移的槽位时：")]),e._v(" "),v("ul",[v("li",[e._v("如果命令要处理的键还存在于槽里面， 那么这个命令将由节点 A 处理。")]),e._v(" "),v("li",[e._v("如果命令要处理的键未存在于槽里面（比如说，要向槽添加一个新的键）返回ASK错误指示客户端将命令发到B节点处理，客户端需要先发送ASKING命令再发送实际请求，否则B节点拒绝处理。")])]),e._v(" "),v("h3",{attrs:{id:"线性扩展"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线性扩展"}},[e._v("#")]),e._v(" 线性扩展")]),e._v(" "),v("h4",{attrs:{id:"添加master节点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#添加master节点"}},[e._v("#")]),e._v(" 添加Master节点")]),e._v(" "),v("ul",[v("li",[e._v("创建一个空节点")]),e._v(" "),v("li",[e._v("将空节点添加到集群")]),e._v(" "),v("li",[e._v("移动某些slot移动到这个空节点")])]),e._v(" "),v("h4",{attrs:{id:"添加slave节点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#添加slave节点"}},[e._v("#")]),e._v(" 添加Slave节点")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("创建一个空节点")])]),e._v(" "),v("li",[v("p",[e._v("将空节点添加到集群")])]),e._v(" "),v("li",[v("p",[e._v("使用replicate命令，指定空节点为某个节点的Slave")]),e._v(" "),v("blockquote",[v("p",[e._v("redis 127.0.0.1:7006> cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e")])])])]),e._v(" "),v("h3",{attrs:{id:"转向错误"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#转向错误"}},[e._v("#")]),e._v(" 转向错误")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("MOVED错误")]),e._v(" "),v("p",[e._v("所查找的槽不是由该节点处理的话， 节点将查看自身内部所保存的哈希槽到节点 ID 的映射记录， 并向客户端回复一个 MOVED 错误。")]),e._v(" "),v("blockquote",[v("p",[e._v("GET x")])]),e._v(" "),v("blockquote",[v("p",[e._v("-MOVED 3999 127.0.0.1:6381")])])]),e._v(" "),v("li",[v("p",[e._v("ASK错误")]),e._v(" "),v("p",[e._v("当节点需要让客户端仅仅在下一个命令请求中转向至另一个节点时， 节点向客户端返回 ASK 转向，客户端先发送一个 ASKING 命令，然后再发送真正的命令请求，否则带有 IMPORTING 状态的槽的命令请求将被拒绝执行，多见于发生slot的迁移过程中，迁移完成后再请求则返回MOVED错误。")])])]),e._v(" "),v("h3",{attrs:{id:"多key操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多key操作"}},[e._v("#")]),e._v(" 多KEY操作")]),e._v(" "),v("p",[e._v("不支持跨节点多key操作，如果一定要使用多key操作，请确保所有的key都在一个node上，具体方法是使用“hash tag”方案，hash tag方案是一种数据分布的例外情况。")]),e._v(" "),v("ul",[v("li",[e._v("第1个“{”跟第一个“}”之间的内容进行hash")]),e._v(" "),v("li",[e._v("{user100}.name、{user100}.age这两个健将被hash到同一个slot，默认这两个KEY会分布在不同的Slot中。")])])])}),[],!1,null,null,null);a.default=t.exports}}]);